Download Link: https://assignmentchef.com/product/solved-cs-1410-project-8-dynamic-array-template
<br>
13.4 Programming Project #8:Dynamic Array TemplateBackgroundAt this point you should have written code for a complete vector of integers class (TheDynamic Array project). We will add a few additional functions to DynArray, and thenmake it a class template so it can store objects of any type.ObjectiveSuccessfully implement a generic class using templates in C++.Step 1Starting with a copy of your DynArray class, add the following member functions:1. int back()This function returns the value of the last integer in the used portion of thevector, but it does not remove it. Throw a runtime_error if the vector isempty. This function returns by reference.2. int front()This function returns the value at the beginning the vector, but it does notremove it. Throw a runtime_error if the vector is empty. This function returnsby reference.3. DynArray(const DynArray&amp;)This copy constructor does a deep copy of the object’s contents.4. DynArray&amp; operator=(const DynArray&amp;)This assignment operator does a deep copy of the object’s contents. Don’tforget to delete the old data.5. T&amp; operator[ ](int n);This operator modifies the array operator so that is it compatible with a vectorat( ) function in avoiding the fact that an array has no over bounds errorreporting.After you have added these functions to your new DynArray class, write a driver thattests these new functions. Once you are satisfied that your DynArray class works,move on to step two. You won’t turn in your test code for this step.Step 2Make your DynArray class generic by making it a template. Your new class templatewill have the type of the items it will hold as the template parameter:template&lt;typename T&gt;class DynArray {… your content here …};You will need to move all of your code into a single dynarray.h file, since template codemust be defined that way. You won’t have a dynarray.cpp. Place the class templatedefinition first, followed by the member function implementations (alternatively, youcould define your member function bodies inside the class template if you like). Youwill need to add the usual template preamble before each function defined outside ofthe class template definition, for example:template&lt;typename T&gt;int DynArray&lt;T&gt;::capacity() const {return cap; // Or whatever you named your capacity datamember}Now go through your code and replace all occurrences of int with T wherever theelement type is referred to. Don’t just blindly replace all occurrences of int. Forexample, capacity still returns an int, since it is a number. push_back, however,will look like this:template&lt;typename T&gt;void DynArray&lt;T&gt;::push_back(const T&amp; t) {…your code here…}Note: Wherever DynArray appears in the non-template version (except for the classname and the names of constructors), it must now appear as DynArray&lt;T&gt;.The driver for this project is provided for you.The expected output follows:growgrowgrowcopy[A, B, C, D, E, F, G, H, I, J, K, …, Z]assign[A, B, C, D, E, F, G, H, I, J, K, …, Z]{B, C, D, E, F, G, H, I, J, K}Note that you must insert trace statements for “grow” and “assign”. This verifies thatyour code is functioning properly.